from Superclass import Parent # "Связываем" файлы и классы. # Импортируем сюда из файла Superclass класс Parent.
class Child(Parent): # Так выглядит запись "наследования". # Child - дочерний класс, который наследуется от родительского Parent.
    def __init__(self, login, password, id, name, name2): # В свойства конструктора передаём 1 дополнительный параметр
        Parent.__init__(self, login, password, id, name) # Передаём в конструктор дочернего класса конктруктор родительского
        self.__name2 = name2
    #def show(self): # Создаём метод внутри дочернего класса. # Теперь объекту дочернего класса можно использовать этот метод.
        #print(f'{self.__login}\n{self.__password}') # тут будет ошибка, так как данные внутри род. # класса - инкапсулированные
    def Show_info(self): # описываем переопределённый метод родительского класса в дочернем.
        print(f'{self.id}\n{self.name}\n{self.__name2}') # Операции будем производить с неинкапсулированными свойствами.
        Parent.Show_info(self) # Через обращение к методу родительского класса "напрямую" вызываем
                               # метод из родительского класса, который показывает инкапсулированные данные.
                               # В принципе, данная запись не обязательна в коде при переопределении,
                               # но для наглядности неплохо будет это видеть.

x = Child('qwerty', '1234567890', 1, 'alexey', 'taratov') # При создании объекта дочернего класса необходимо передать то количество атрибутов,# которое есть в родительском.# (Если при этом в самом дочернем классе атрибутов новых нет)
x.Show_info() # Вызываем метод родительского класса применительно к объекту дочернего класса. Так делать можно.
